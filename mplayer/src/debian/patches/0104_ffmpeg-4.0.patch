Description: Fix FTBFS with FFmpeg 4.0
 This patch is a combination of the below upstream commits, backported to
 1.3.0.
 .
 Some parts which are only relevant to static FFmpeg have been removed because
 they don't need patching in Debian.
 - Disabling of vf_mcdeint.c
Origin: backport, commit:37998
Origin: backport, commit:37999
Origin: backport, commit:38001
Bug-Debian: https://bugs.debian.org/888378
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/

--- a/libmpdemux/demuxer.c
+++ b/libmpdemux/demuxer.c
@@ -50,7 +50,7 @@
 
 #ifdef CONFIG_FFMPEG
 #include "libavcodec/avcodec.h"
-#if MP_INPUT_BUFFER_PADDING_SIZE < FF_INPUT_BUFFER_PADDING_SIZE
+#if MP_INPUT_BUFFER_PADDING_SIZE < AV_INPUT_BUFFER_PADDING_SIZE
 #error MP_INPUT_BUFFER_PADDING_SIZE is too small!
 #endif
 #include "av_helpers.h"
--- a/libmpdemux/demux_lavf.c
+++ b/libmpdemux/demux_lavf.c
@@ -176,7 +176,7 @@ static int lavf_check_file(demuxer_t *de
     }
 
     avpd.buf = av_mallocz(FFMAX(BIO_BUFFER_SIZE, PROBE_BUF_SIZE) +
-                          FF_INPUT_BUFFER_PADDING_SIZE);
+                          AV_INPUT_BUFFER_PADDING_SIZE);
     do {
         read_size = stream_read(demuxer->stream, avpd.buf + probe_data_size, read_size);
         if(read_size < 0) {
--- a/libmpcodecs/ad_ffmpeg.c
+++ b/libmpcodecs/ad_ffmpeg.c
@@ -134,7 +134,7 @@ static int init(sh_audio_t *sh_audio)
 
     /* alloc extra data */
     if (sh_audio->wf && sh_audio->wf->cbSize > 0) {
-        lavc_context->extradata = av_mallocz(sh_audio->wf->cbSize + FF_INPUT_BUFFER_PADDING_SIZE);
+        lavc_context->extradata = av_mallocz(sh_audio->wf->cbSize + AV_INPUT_BUFFER_PADDING_SIZE);
         lavc_context->extradata_size = sh_audio->wf->cbSize;
         memcpy(lavc_context->extradata, sh_audio->wf + 1,
                lavc_context->extradata_size);
--- a/libmpcodecs/vf_uspp.c
+++ b/libmpcodecs/vf_uspp.c
@@ -240,7 +240,7 @@ static int config(struct vf_instance *vf
             avctx_enc->gop_size = 300;
             avctx_enc->max_b_frames= 0;
             avctx_enc->pix_fmt = AV_PIX_FMT_YUV420P;
-            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
+            avctx_enc->flags = AV_CODEC_FLAG_QSCALE | AV_CODEC_FLAG_LOW_DELAY;
             avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
             avctx_enc->global_quality= 123;
             av_dict_set(&opts, "no_bitstream", "1", 0);
--- a/libmpcodecs/vf_lavc.c
+++ b/libmpcodecs/vf_lavc.c
@@ -157,7 +157,7 @@ static int vf_open(vf_instance_t *vf, ch
 
     if(p_quality<32){
 	// fixed qscale
-	lavc_venc_context.flags = CODEC_FLAG_QSCALE;
+	lavc_venc_context.flags = AV_CODEC_FLAG_QSCALE;
 	lavc_venc_context.global_quality =
 	vf->priv->pic->quality = (int)(FF_QP2LAMBDA * ((p_quality<1) ? 1 : p_quality) + 0.5);
     } else {
--- a/libmpcodecs/ae_lavc.c
+++ b/libmpcodecs/ae_lavc.c
@@ -224,10 +224,10 @@ int mpae_init_lavc(audio_encoder_t *enco
 	}
         if((lavc_param_audio_global_header&1)
         /*|| (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))*/){
-                lavc_actx->flags |= CODEC_FLAG_GLOBAL_HEADER;
+                lavc_actx->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
         }
         if(lavc_param_audio_global_header&2){
-                lavc_actx->flags2 |= CODEC_FLAG2_LOCAL_HEADER;
+                lavc_actx->flags2 |= AV_CODEC_FLAG2_LOCAL_HEADER;
         }
 
 	if(avcodec_open2(lavc_actx, lavc_acodec, NULL) < 0)
--- a/libmpcodecs/vd_ffmpeg.c
+++ b/libmpcodecs/vd_ffmpeg.c
@@ -115,8 +115,7 @@ static int lavc_param_gray=0;
 static int lavc_param_vstats=0;
 static int lavc_param_idct_algo=0;
 static int lavc_param_debug=0;
-static int lavc_param_vismv=0;
-#ifdef CODEC_FLAG2_SHOW_ALL
+#ifdef AV_CODEC_FLAG2_SHOW_ALL
 static int lavc_param_wait_keyframe=0;
 #endif
 static int lavc_param_skip_top=0;
@@ -141,24 +140,23 @@ static const mp_image_t mpi_no_picture =
 const m_option_t lavc_decode_opts_conf[]={
     {"bug"           , &lavc_param_workaround_bugs      , CONF_TYPE_INT     , CONF_RANGE, -1, 999999, NULL},
     {"er"            , &lavc_param_error_resilience     , CONF_TYPE_INT     , CONF_RANGE, 0, 99, NULL},
-    {"gray"          , &lavc_param_gray                 , CONF_TYPE_FLAG    , 0, 0, CODEC_FLAG_GRAY, NULL},
+    {"gray"          , &lavc_param_gray                 , CONF_TYPE_FLAG    , 0, 0, AV_CODEC_FLAG_GRAY, NULL},
     {"idct"          , &lavc_param_idct_algo            , CONF_TYPE_INT     , CONF_RANGE, 0, 99, NULL},
     {"ec"            , &lavc_param_error_concealment    , CONF_TYPE_INT     , CONF_RANGE, 0, 99, NULL},
     {"vstats"        , &lavc_param_vstats               , CONF_TYPE_FLAG    , 0, 0, 1, NULL},
     {"debug"         , &lavc_param_debug                , CONF_TYPE_INT     , CONF_RANGE, 0, 9999999, NULL},
-    {"vismv"         , &lavc_param_vismv                , CONF_TYPE_INT     , CONF_RANGE, 0, 9999999, NULL},
-#ifdef CODEC_FLAG2_SHOW_ALL
+#ifdef AV_CODEC_FLAG2_SHOW_ALL
     {"wait_keyframe" , &lavc_param_wait_keyframe        , CONF_TYPE_FLAG    , 0, 0, 1, NULL},
 #endif
     {"st"            , &lavc_param_skip_top             , CONF_TYPE_INT     , CONF_RANGE, 0, 999, NULL},
     {"sb"            , &lavc_param_skip_bottom          , CONF_TYPE_INT     , CONF_RANGE, 0, 999, NULL},
-    {"fast"          , &lavc_param_fast                 , CONF_TYPE_FLAG    , 0, 0, CODEC_FLAG2_FAST, NULL},
+    {"fast"          , &lavc_param_fast                 , CONF_TYPE_FLAG    , 0, 0, AV_CODEC_FLAG2_FAST, NULL},
     {"lowres"        , &lavc_param_lowres_str           , CONF_TYPE_STRING  , 0, 0, 0, NULL},
     {"skiploopfilter", &lavc_param_skip_loop_filter_str , CONF_TYPE_STRING  , 0, 0, 0, NULL},
     {"skipidct"      , &lavc_param_skip_idct_str        , CONF_TYPE_STRING  , 0, 0, 0, NULL},
     {"skipframe"     , &lavc_param_skip_frame_str       , CONF_TYPE_STRING  , 0, 0, 0, NULL},
     {"threads"       , &lavc_param_threads              , CONF_TYPE_INT     , CONF_RANGE, 1, 16, NULL},
-    {"bitexact"      , &lavc_param_bitexact             , CONF_TYPE_FLAG    , 0, 0, CODEC_FLAG_BITEXACT, NULL},
+    {"bitexact"      , &lavc_param_bitexact             , CONF_TYPE_FLAG    , 0, 0, AV_CODEC_FLAG_BITEXACT, NULL},
     {"o"             , &lavc_avopt                      , CONF_TYPE_STRING  , 0, 0, 0, NULL},
     {NULL, NULL, 0, 0, 0, 0, NULL}
 };
@@ -196,7 +194,7 @@ static int control(sh_video_t *sh, int c
 #if CONFIG_XVMC
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
-            if(avctx->pix_fmt == AV_PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+            if(avctx->pix_fmt == AV_PIX_FMT_XVMC) return CONTROL_TRUE;
 #endif
         }
         return CONTROL_FALSE;
@@ -257,9 +255,9 @@ static void set_dr_slice_settings(struct
     // explicitly requested
     int use_slices = vd_use_slices > 0 || (vd_use_slices <  0 && lavc_param_threads <= 1);
 
-    ctx->do_slices = use_slices && (lavc_codec->capabilities & CODEC_CAP_DRAW_HORIZ_BAND);
+    ctx->do_slices = use_slices && (lavc_codec->capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND);
 
-    ctx->do_dr1 = (lavc_codec->capabilities & CODEC_CAP_DR1) &&
+    ctx->do_dr1 = (lavc_codec->capabilities & AV_CODEC_CAP_DR1) &&
         lavc_codec->id != AV_CODEC_ID_INTERPLAY_VIDEO &&
         lavc_codec->id != AV_CODEC_ID_H264 &&
         lavc_codec->id != AV_CODEC_ID_HEVC;
@@ -271,12 +269,9 @@ static void set_dr_slice_settings(struct
         ctx->do_dr1 = 1;
         ctx->nonref_dr = 1;
     }
-    if (lavc_param_vismv || (lavc_param_debug & (FF_DEBUG_VIS_MB_TYPE|FF_DEBUG_VIS_QP))) {
-        ctx->do_slices = ctx->do_dr1 = 0;
-    }
     if(ctx->do_dr1){
         avctx->get_buffer2 = get_buffer2;
-    } else if (lavc_codec->capabilities & CODEC_CAP_DR1) {
+    } else if (lavc_codec->capabilities & AV_CODEC_CAP_DR1) {
         avctx->get_buffer2 = avcodec_default_get_buffer2;
     }
     avctx->slice_flags = 0;
@@ -372,9 +367,9 @@ static int init(sh_video_t *sh){
     case 1:
         avctx->err_recognition |= AV_EF_CAREFUL;
     }
-    lavc_param_gray|= CODEC_FLAG_GRAY;
-#ifdef CODEC_FLAG2_SHOW_ALL
-    if(!lavc_param_wait_keyframe) avctx->flags2 |= CODEC_FLAG2_SHOW_ALL;
+    lavc_param_gray|= AV_CODEC_FLAG_GRAY;
+#ifdef AV_CODEC_FLAG2_SHOW_ALL
+    if(!lavc_param_wait_keyframe) avctx->flags2 |= AV_CODEC_FLAG2_SHOW_ALL;
 #endif
     avctx->flags2|= lavc_param_fast;
     avctx->codec_tag= sh->format;
@@ -383,7 +378,6 @@ static int init(sh_video_t *sh){
     avctx->debug= lavc_param_debug;
     if (lavc_param_debug)
         av_log_set_level(AV_LOG_DEBUG);
-    avctx->debug_mv= lavc_param_vismv;
     avctx->skip_top   = lavc_param_skip_top;
     avctx->skip_bottom= lavc_param_skip_bottom;
     if(lavc_param_lowres_str != NULL)
@@ -419,7 +413,7 @@ static int init(sh_video_t *sh){
        handled here; the second case falls through to the next section. */
         if (sh->ImageDesc) {
             avctx->extradata_size = (*(int *)sh->ImageDesc) - sizeof(int);
-            avctx->extradata = av_mallocz(avctx->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
             memcpy(avctx->extradata, ((int *)sh->ImageDesc)+1, avctx->extradata_size);
             break;
         }
@@ -434,7 +428,7 @@ static int init(sh_video_t *sh){
             break;
         av_dict_set(&opts, "extern_huff", "1", 0);
         avctx->extradata_size = sh->bih->biSize-sizeof(*sh->bih);
-        avctx->extradata = av_mallocz(avctx->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+        avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
         memcpy(avctx->extradata, sh->bih+1, avctx->extradata_size);
 
 #if 0
@@ -457,14 +451,14 @@ static int init(sh_video_t *sh){
         if(sh->bih->biSize<sizeof(*sh->bih)+8){
             /* only 1 packet per frame & sub_id from fourcc */
             avctx->extradata_size= 8;
-            avctx->extradata = av_mallocz(avctx->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
             ((uint32_t *)avctx->extradata)[0] = 0;
             ((uint32_t *)avctx->extradata)[1] =
                 (sh->format == mmioFOURCC('R', 'V', '1', '3')) ? 0x10003001 : 0x10000000;
         } else {
             /* has extra slice header (demux_rm or rm->avi streamcopy) */
             avctx->extradata_size = sh->bih->biSize-sizeof(*sh->bih);
-            avctx->extradata = av_mallocz(avctx->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
             memcpy(avctx->extradata, sh->bih+1, avctx->extradata_size);
         }
 
@@ -475,7 +469,7 @@ static int init(sh_video_t *sh){
         if (!sh->bih || sh->bih->biSize <= sizeof(*sh->bih))
             break;
         avctx->extradata_size = sh->bih->biSize-sizeof(*sh->bih);
-        avctx->extradata = av_mallocz(avctx->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+        avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
         memcpy(avctx->extradata, sh->bih+1, avctx->extradata_size);
         break;
     }
--- a/libmpcodecs/ve_lavc.c
+++ b/libmpcodecs/ve_lavc.c
@@ -63,12 +63,9 @@ static int lavc_param_vbitrate = -1;
 static int lavc_param_vrate_tolerance = 1000*8;
 static int lavc_param_mb_decision = 0; /* default is realtime encoding */
 static int lavc_param_v4mv = 0;
-static int lavc_param_vme = 4;
 static float lavc_param_vqscale = -1;
 static int lavc_param_vqmin = 2;
 static int lavc_param_vqmax = 31;
-static float lavc_param_lmin = 2;
-static float lavc_param_lmax = 31;
 static float lavc_param_mb_lmin = 2;
 static float lavc_param_mb_lmax = 31;
 static int lavc_param_vqdiff = 3;
@@ -81,22 +78,15 @@ static float lavc_param_vi_qoffset = 0.0
 static int lavc_param_vmax_b_frames = 0;
 static int lavc_param_keyint = -1;
 static int lavc_param_vpass = 0;
-static int lavc_param_vrc_strategy = 0;
 static int lavc_param_vb_strategy = 0;
 static int lavc_param_packet_size= 0;
 static int lavc_param_strict= -1;
 static int lavc_param_data_partitioning= 0;
 static int lavc_param_gray=0;
-static float lavc_param_rc_qsquish=1.0;
-static float lavc_param_rc_qmod_amp=0;
-static int lavc_param_rc_qmod_freq=0;
 static char *lavc_param_rc_override_string=NULL;
-static char *lavc_param_rc_eq="tex^qComp";
 static int lavc_param_rc_buffer_size=0;
-static float lavc_param_rc_buffer_aggressivity=1.0;
 static int lavc_param_rc_max_rate=0;
 static int lavc_param_rc_min_rate=0;
-static float lavc_param_rc_initial_cplx=0;
 static float lavc_param_rc_initial_buffer_occupancy=0.9;
 static int lavc_param_mpeg_quant=0;
 static int lavc_param_fdct=0;
@@ -108,8 +98,6 @@ static float lavc_param_dark_masking= 0.
 static float lavc_param_temporal_cplx_masking= 0.0;
 static float lavc_param_spatial_cplx_masking= 0.0;
 static float lavc_param_p_masking= 0.0;
-static float lavc_param_border_masking= 0.0;
-static int lavc_param_normalize_aqp= 0;
 static int lavc_param_interlaced_dct= 0;
 static int lavc_param_prediction_method= FF_PRED_LEFT;
 static int lavc_param_format= IMGFMT_YV12;
@@ -131,15 +119,12 @@ static int lavc_param_bit_exact = 0;
 static int lavc_param_aic= 0;
 static int lavc_param_aiv= 0;
 static int lavc_param_umv= 0;
-static int lavc_param_gmc= 0;
 static int lavc_param_obmc= 0;
 static int lavc_param_loop= 0;
 static int lavc_param_last_pred= 0;
 static int lavc_param_pre_me= 1;
 static int lavc_param_me_subpel_quality= 8;
 static int lavc_param_me_range= 0;
-static int lavc_param_ibias= FF_DEFAULT_QUANT_BIAS;
-static int lavc_param_pbias= FF_DEFAULT_QUANT_BIAS;
 static int lavc_param_coder= 0;
 static int lavc_param_context= 0;
 static char *lavc_param_intra_matrix = NULL;
@@ -162,7 +147,6 @@ static int lavc_param_skip_exp=0;
 static int lavc_param_skip_cmp=0;
 static int lavc_param_brd_scale = 0;
 static int lavc_param_bidir_refine = 0;
-static int lavc_param_sc_factor = 1;
 static int lavc_param_video_global_header= 0;
 static int lavc_param_mv0_threshold = 256;
 static int lavc_param_refs = 1;
@@ -190,21 +174,21 @@ const m_option_t lavcopts_conf[]={
 	{"vhq", &lavc_param_mb_decision, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"mbd", &lavc_param_mb_decision, CONF_TYPE_INT, CONF_RANGE, 0, 9, NULL},
 	{"v4mv", &lavc_param_v4mv, CONF_TYPE_FLAG, 0, 0, 1, NULL},
-	{"vme", &lavc_param_vme, CONF_TYPE_INT, CONF_RANGE, 0, 8, NULL},
+	{"vme", "vme has no effect, please use the corresponding codec specific option (see FFmpeg documentation) instead of vme.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"vqscale", &lavc_param_vqscale, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 255.0, NULL},
 	{"vqmin", &lavc_param_vqmin, CONF_TYPE_INT, CONF_RANGE, 1, 31, NULL},
 	{"vqmax", &lavc_param_vqmax, CONF_TYPE_INT, CONF_RANGE, 1, 31, NULL},
-	{"lmin", &lavc_param_lmin, CONF_TYPE_FLOAT, CONF_RANGE, 0.01, 255.0, NULL},
-	{"lmax", &lavc_param_lmax, CONF_TYPE_FLOAT, CONF_RANGE, 0.01, 255.0, NULL},
+        {"lmin", "Please use o=lmin=<value>*QP2LAMBDA instead of lmin.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
+        {"lmax", "Please use o=lmax=<value>*QP2LAMBDA instead of lmax.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"mblmin", &lavc_param_mb_lmin, CONF_TYPE_FLOAT, CONF_RANGE, 0.01, 255.0, NULL},
 	{"mblmax", &lavc_param_mb_lmax, CONF_TYPE_FLOAT, CONF_RANGE, 0.01, 255.0, NULL},
 	{"vqdiff", &lavc_param_vqdiff, CONF_TYPE_INT, CONF_RANGE, 1, 31, NULL},
 	{"vqcomp", &lavc_param_vqcompress, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 1.0, NULL},
 	{"vqblur", &lavc_param_vqblur, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 1.0, NULL},
 	{"vb_qfactor", &lavc_param_vb_qfactor, CONF_TYPE_FLOAT, CONF_RANGE, -31.0, 31.0, NULL},
-	{"vmax_b_frames", &lavc_param_vmax_b_frames, CONF_TYPE_INT, CONF_RANGE, 0, FF_MAX_B_FRAMES, NULL},
+	{"vmax_b_frames", &lavc_param_vmax_b_frames, CONF_TYPE_INT, CONF_RANGE, 0, 16, NULL}, // FF_MAX_B_FRAMES was removed from FFmpeg. We still use its value here, so we probably limit ourselves in some cases.
 	{"vpass", &lavc_param_vpass, CONF_TYPE_INT, CONF_RANGE, 0, 3, NULL},
-	{"vrc_strategy", &lavc_param_vrc_strategy, CONF_TYPE_INT, CONF_RANGE, 0, 2, NULL},
+	{"vrc_strategy", "Please use o=rc_strategy=<value> instead of vrc_strategy.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"vb_strategy", &lavc_param_vb_strategy, CONF_TYPE_INT, CONF_RANGE, 0, 10, NULL},
 	{"vb_qoffset", &lavc_param_vb_qoffset, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 31.0, NULL},
 	{"vlelim", "Please use o=luma_elim_threshold=<value> instead of vlelim.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
@@ -213,20 +197,20 @@ const m_option_t lavcopts_conf[]={
 	{"vstrict", &lavc_param_strict, CONF_TYPE_INT, CONF_RANGE, -99, 99, NULL},
 	{"vdpart", &lavc_param_data_partitioning, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"keyint", &lavc_param_keyint, CONF_TYPE_INT, 0, 0, 0, NULL},
-	{"gray", &lavc_param_gray, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_GRAY, NULL},
+	{"gray", &lavc_param_gray, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_GRAY, NULL},
 	{"mpeg_quant", &lavc_param_mpeg_quant, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"vi_qfactor", &lavc_param_vi_qfactor, CONF_TYPE_FLOAT, CONF_RANGE, -31.0, 31.0, NULL},
 	{"vi_qoffset", &lavc_param_vi_qoffset, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 31.0, NULL},
-	{"vqsquish", &lavc_param_rc_qsquish, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 99.0, NULL},
-	{"vqmod_amp", &lavc_param_rc_qmod_amp, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 99.0, NULL},
-	{"vqmod_freq", &lavc_param_rc_qmod_freq, CONF_TYPE_INT, 0, 0, 0, NULL},
-	{"vrc_eq", &lavc_param_rc_eq, CONF_TYPE_STRING, 0, 0, 0, NULL},
+	{"vqsquish", "Please use o=qsquish=<value> instead of vqsquish.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
+	{"vqmod_amp", "Please use o=rc_qmod_amp=<value> instead of vqmod_amp.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
+	{"vqmod_freq", "Please use o=rc_qmod_freq=<value> instead of vqmod_freq.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
+	{"vrc_eq", "Please use o=rc_eq=<value> instead of vrc_eq.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"vrc_override", &lavc_param_rc_override_string, CONF_TYPE_STRING, 0, 0, 0, NULL},
 	{"vrc_maxrate", &lavc_param_rc_max_rate, CONF_TYPE_INT, CONF_RANGE, 0, MAX_BITRATE, NULL},
 	{"vrc_minrate", &lavc_param_rc_min_rate, CONF_TYPE_INT, CONF_RANGE, 0, MAX_BITRATE, NULL},
 	{"vrc_buf_size", &lavc_param_rc_buffer_size, CONF_TYPE_INT, CONF_RANGE, 4, MAX_BITRATE, NULL},
-	{"vrc_buf_aggressivity", &lavc_param_rc_buffer_aggressivity, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 99.0, NULL},
-	{"vrc_init_cplx", &lavc_param_rc_initial_cplx, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 9999999.0, NULL},
+	{"vrc_buf_aggressivity", "Please use o=rc_buf_aggressivity=<value> instead of vrc_buf_aggressivity.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
+	{"vrc_init_cplx", "Please use o=rc_init_cplx=<value> instead of vrc_init_cplx.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"vrc_init_occupancy", &lavc_param_rc_initial_buffer_occupancy, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 1.0, NULL},
         {"vfdct", &lavc_param_fdct, CONF_TYPE_INT, CONF_RANGE, 0, 10, NULL},
 	{"aspect", &lavc_param_aspect, CONF_TYPE_STRING, 0, 0, 0, NULL},
@@ -235,14 +219,14 @@ const m_option_t lavcopts_conf[]={
 	{"tcplx_mask", &lavc_param_temporal_cplx_masking, CONF_TYPE_FLOAT, CONF_RANGE, -1.0, 1.0, NULL},
 	{"scplx_mask", &lavc_param_spatial_cplx_masking, CONF_TYPE_FLOAT, CONF_RANGE, -1.0, 1.0, NULL},
 	{"p_mask", &lavc_param_p_masking, CONF_TYPE_FLOAT, CONF_RANGE, -1.0, 1.0, NULL},
-	{"naq", &lavc_param_normalize_aqp, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"naq", "Please use o=mpv_flags=+naq instead of naq.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"dark_mask", &lavc_param_dark_masking, CONF_TYPE_FLOAT, CONF_RANGE, -1.0, 1.0, NULL},
 	{"ildct", &lavc_param_interlaced_dct, CONF_TYPE_FLAG, 0, 0, 1, NULL},
         {"idct", &lavc_param_idct, CONF_TYPE_INT, CONF_RANGE, 0, 20, NULL},
         {"pred", &lavc_param_prediction_method, CONF_TYPE_INT, CONF_RANGE, 0, 20, NULL},
         {"format", &lavc_param_format, CONF_TYPE_IMGFMT, 0, 0, 0, NULL},
         {"debug", &lavc_param_debug, CONF_TYPE_INT, CONF_RANGE, 0, 100000000, NULL},
-        {"psnr", &lavc_param_psnr, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_PSNR, NULL},
+        {"psnr", &lavc_param_psnr, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_PSNR, NULL},
         {"precmp", &lavc_param_me_pre_cmp, CONF_TYPE_INT, CONF_RANGE, 0, 2000, NULL},
         {"cmp", &lavc_param_me_cmp, CONF_TYPE_INT, CONF_RANGE, 0, 2000, NULL},
         {"subcmp", &lavc_param_me_sub_cmp, CONF_TYPE_INT, CONF_RANGE, 0, 2000, NULL},
@@ -251,23 +235,23 @@ const m_option_t lavcopts_conf[]={
 #ifdef FF_CMP_VSAD
         {"ildctcmp", &lavc_param_ildct_cmp, CONF_TYPE_INT, CONF_RANGE, 0, 2000, NULL},
 #endif
-        {"bit_exact", &lavc_param_bit_exact, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_BITEXACT, NULL},
+        {"bit_exact", &lavc_param_bit_exact, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_BITEXACT, NULL},
         {"predia", &lavc_param_pre_dia_size, CONF_TYPE_INT, CONF_RANGE, -2000, 2000, NULL},
         {"dia", &lavc_param_dia_size, CONF_TYPE_INT, CONF_RANGE, -2000, 2000, NULL},
-	{"qpel", &lavc_param_qpel, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_QPEL, NULL},
+	{"qpel", &lavc_param_qpel, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_QPEL, NULL},
 	{"trell", &lavc_param_trell, CONF_TYPE_FLAG, 0, 0, 1, NULL},
-	{"lowdelay", &lavc_param_lowdelay, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_LOW_DELAY, NULL},
+	{"lowdelay", &lavc_param_lowdelay, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_LOW_DELAY, NULL},
 	{"last_pred", &lavc_param_last_pred, CONF_TYPE_INT, CONF_RANGE, 0, 2000, NULL},
 	{"preme", &lavc_param_pre_me, CONF_TYPE_INT, CONF_RANGE, 0, 2000, NULL},
 	{"subq", &lavc_param_me_subpel_quality, CONF_TYPE_INT, CONF_RANGE, 0, 8, NULL},
 	{"me_range", &lavc_param_me_range, CONF_TYPE_INT, CONF_RANGE, 0, 16000, NULL},
-	{"aic", &lavc_param_aic, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_AC_PRED, NULL},
+	{"aic", &lavc_param_aic, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_AC_PRED, NULL},
 	{"umv", &lavc_param_umv, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"aiv", &lavc_param_aiv, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"obmc", &lavc_param_obmc, CONF_TYPE_FLAG, 0, 0, 1, NULL},
-	{"loop", &lavc_param_loop, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_LOOP_FILTER, NULL},
-	{"ibias", &lavc_param_ibias, CONF_TYPE_INT, CONF_RANGE, -512, 512, NULL},
-	{"pbias", &lavc_param_pbias, CONF_TYPE_INT, CONF_RANGE, -512, 512, NULL},
+	{"loop", &lavc_param_loop, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_LOOP_FILTER, NULL},
+	{"ibias", "Please use o=ibias=<value> instead of ibias.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
+	{"pbias", "Please use o=pbias=<value> instead of pbias.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"coder", &lavc_param_coder, CONF_TYPE_INT, CONF_RANGE, 0, 10, NULL},
 	{"context", &lavc_param_context, CONF_TYPE_INT, CONF_RANGE, 0, 10, NULL},
 	{"intra_matrix", &lavc_param_intra_matrix, CONF_TYPE_STRING, 0, 0, 0, NULL},
@@ -278,11 +262,11 @@ const m_option_t lavcopts_conf[]={
 	{"qprd", "Please use o=mpv_flags=+qp_rd instead of qprd.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"ss", &lavc_param_ss, CONF_TYPE_FLAG, 0, 0, 1, NULL},
 	{"alt", &lavc_param_alt, CONF_TYPE_FLAG, 0, 0, 1, NULL},
-	{"ilme", &lavc_param_ilme, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_INTERLACED_ME, NULL},
-	{"cgop", &lavc_param_closed_gop, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_CLOSED_GOP, NULL},
-	{"gmc", &lavc_param_gmc, CONF_TYPE_FLAG, 0, 0, CODEC_FLAG_GMC, NULL},
+	{"ilme", &lavc_param_ilme, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_INTERLACED_ME, NULL},
+	{"cgop", &lavc_param_closed_gop, CONF_TYPE_FLAG, 0, 0, AV_CODEC_FLAG_CLOSED_GOP, NULL},
+	{"gmc", "Please use o=gmc=<value> instead of gmc.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"dc", &lavc_param_dc_precision, CONF_TYPE_INT, CONF_RANGE, 8, 11, NULL},
-	{"border_mask", &lavc_param_border_masking, CONF_TYPE_FLOAT, CONF_RANGE, 0.0, 1.0, NULL},
+	{"border_mask", "Please use o=border_mask=<value> instead of border_mask.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"inter_threshold", "inter_threshold has no effect, please remove it.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"sc_threshold", &lavc_param_sc_threshold, CONF_TYPE_INT, CONF_RANGE, -1000000000, 1000000000, NULL},
 	{"top", &lavc_param_top, CONF_TYPE_INT, CONF_RANGE, -1, 1, NULL},
@@ -295,7 +279,7 @@ const m_option_t lavcopts_conf[]={
         {"skip_exp", &lavc_param_skip_exp, CONF_TYPE_INT, CONF_RANGE, 0, 1000000, NULL},
 	{"brd_scale", &lavc_param_brd_scale, CONF_TYPE_INT, CONF_RANGE, 0, 10, NULL},
 	{"bidir_refine", &lavc_param_bidir_refine, CONF_TYPE_INT, CONF_RANGE, 0, 4, NULL},
-	{"sc_factor", &lavc_param_sc_factor, CONF_TYPE_INT, CONF_RANGE, 1, INT_MAX, NULL},
+	{"sc_factor", "sc_factor has no effect, please remove it.\n", CONF_TYPE_PRINT, 0, 0, 0, NULL},
 	{"vglobal", &lavc_param_video_global_header, CONF_TYPE_INT, CONF_RANGE, 0, INT_MAX, NULL},
 	{"aglobal", &lavc_param_audio_global_header, CONF_TYPE_INT, CONF_RANGE, 0, INT_MAX, NULL},
 	{"mv0_threshold", &lavc_param_mv0_threshold, CONF_TYPE_INT, CONF_RANGE, 0, INT_MAX, NULL},
@@ -351,8 +335,6 @@ static int config(struct vf_instance *vf
     lavc_venc_context->time_base= (AVRational){mux_v->h.dwScale, mux_v->h.dwRate};
     lavc_venc_context->qmin= lavc_param_vqmin;
     lavc_venc_context->qmax= lavc_param_vqmax;
-    lavc_venc_context->lmin= (int)(FF_QP2LAMBDA * lavc_param_lmin + 0.5);
-    lavc_venc_context->lmax= (int)(FF_QP2LAMBDA * lavc_param_lmax + 0.5);
     lavc_venc_context->mb_lmin= (int)(FF_QP2LAMBDA * lavc_param_mb_lmin + 0.5);
     lavc_venc_context->mb_lmax= (int)(FF_QP2LAMBDA * lavc_param_mb_lmax + 0.5);
     lavc_venc_context->max_qdiff= lavc_param_vqdiff;
@@ -360,17 +342,12 @@ static int config(struct vf_instance *vf
     lavc_venc_context->qblur= lavc_param_vqblur;
     lavc_venc_context->max_b_frames= lavc_param_vmax_b_frames;
     lavc_venc_context->b_quant_factor= lavc_param_vb_qfactor;
-    lavc_venc_context->rc_strategy= lavc_param_vrc_strategy;
     lavc_venc_context->b_frame_strategy= lavc_param_vb_strategy;
     lavc_venc_context->b_quant_offset= (int)(FF_QP2LAMBDA * lavc_param_vb_qoffset + 0.5);
     lavc_venc_context->rtp_payload_size= lavc_param_packet_size;
     lavc_venc_context->strict_std_compliance= lavc_param_strict;
     lavc_venc_context->i_quant_factor= lavc_param_vi_qfactor;
     lavc_venc_context->i_quant_offset= (int)(FF_QP2LAMBDA * lavc_param_vi_qoffset + 0.5);
-    lavc_venc_context->rc_qsquish= lavc_param_rc_qsquish;
-    lavc_venc_context->rc_qmod_amp= lavc_param_rc_qmod_amp;
-    lavc_venc_context->rc_qmod_freq= lavc_param_rc_qmod_freq;
-    lavc_venc_context->rc_eq= lavc_param_rc_eq;
 
     mux_v->max_rate=
     lavc_venc_context->rc_max_rate= lavc_param_rc_max_rate*1000;
@@ -382,8 +359,6 @@ static int config(struct vf_instance *vf
     lavc_venc_context->rc_initial_buffer_occupancy=
             lavc_venc_context->rc_buffer_size *
             lavc_param_rc_initial_buffer_occupancy;
-    lavc_venc_context->rc_buffer_aggressivity= lavc_param_rc_buffer_aggressivity;
-    lavc_venc_context->rc_initial_cplx= lavc_param_rc_initial_cplx;
     lavc_venc_context->debug= lavc_param_debug;
     lavc_venc_context->last_predictor_count= lavc_param_last_pred;
     lavc_venc_context->pre_me= lavc_param_pre_me;
@@ -391,8 +366,6 @@ static int config(struct vf_instance *vf
     lavc_venc_context->pre_dia_size= lavc_param_pre_dia_size;
     lavc_venc_context->me_subpel_quality= lavc_param_me_subpel_quality;
     lavc_venc_context->me_range= lavc_param_me_range;
-    lavc_venc_context->intra_quant_bias= lavc_param_ibias;
-    lavc_venc_context->inter_quant_bias= lavc_param_pbias;
     lavc_venc_context->coder_type= lavc_param_coder;
     lavc_venc_context->context_model= lavc_param_context;
     lavc_venc_context->scenechange_threshold= lavc_param_sc_threshold;
@@ -479,7 +452,6 @@ static int config(struct vf_instance *vf
     lavc_venc_context->spatial_cplx_masking= lavc_param_spatial_cplx_masking;
     lavc_venc_context->p_masking= lavc_param_p_masking;
     lavc_venc_context->dark_masking= lavc_param_dark_masking;
-        lavc_venc_context->border_masking = lavc_param_border_masking;
 
     if (lavc_param_aspect != NULL)
     {
@@ -543,7 +515,7 @@ static int config(struct vf_instance *vf
     if (lavc_param_obmc)
         av_dict_set(&opts, "obmc", "1", 0);
     lavc_venc_context->flags|= lavc_param_loop;
-    lavc_venc_context->flags|= lavc_param_v4mv ? CODEC_FLAG_4MV : 0;
+    lavc_venc_context->flags|= lavc_param_v4mv ? AV_CODEC_FLAG_4MV : 0;
     if (lavc_param_data_partitioning)
         av_dict_set(&opts, "data_partitioning", "1", 0);
     lavc_venc_context->flags|= lavc_param_mv0;
@@ -552,26 +524,23 @@ static int config(struct vf_instance *vf
     if (lavc_param_alt)
         av_dict_set(&opts, "alternate_scan", "1", 0);
     lavc_venc_context->flags|= lavc_param_ilme;
-    lavc_venc_context->flags|= lavc_param_gmc;
-#ifdef CODEC_FLAG_CLOSED_GOP
+#ifdef AV_CODEC_FLAG_CLOSED_GOP
     lavc_venc_context->flags|= lavc_param_closed_gop;
 #endif
     lavc_venc_context->flags|= lavc_param_gray;
 
-    if(lavc_param_normalize_aqp) lavc_venc_context->flags|= CODEC_FLAG_NORMALIZE_AQP;
-    if(lavc_param_interlaced_dct) lavc_venc_context->flags|= CODEC_FLAG_INTERLACED_DCT;
+    if(lavc_param_interlaced_dct) lavc_venc_context->flags|= AV_CODEC_FLAG_INTERLACED_DCT;
     lavc_venc_context->flags|= lavc_param_psnr;
     lavc_venc_context->intra_dc_precision = lavc_param_dc_precision - 8;
     lavc_venc_context->prediction_method= lavc_param_prediction_method;
     lavc_venc_context->brd_scale = lavc_param_brd_scale;
     lavc_venc_context->bidir_refine = lavc_param_bidir_refine;
-    lavc_venc_context->scenechange_factor = lavc_param_sc_factor;
     if((lavc_param_video_global_header&1)
        /*|| (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))*/){
-        lavc_venc_context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+        lavc_venc_context->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
     }
     if(lavc_param_video_global_header&2){
-        lavc_venc_context->flags2 |= CODEC_FLAG2_LOCAL_HEADER;
+        lavc_venc_context->flags2 |= AV_CODEC_FLAG2_LOCAL_HEADER;
     }
     lavc_venc_context->mv0_threshold = lavc_param_mv0_threshold;
     lavc_venc_context->refs = lavc_param_refs;
@@ -595,7 +564,7 @@ static int config(struct vf_instance *vf
     switch(lavc_param_vpass){
     case 2:
     case 3:
-	lavc_venc_context->flags|= CODEC_FLAG_PASS2;
+	lavc_venc_context->flags|= AV_CODEC_FLAG_PASS2;
 	stats_file= fopen(passtmpfile, "rb");
 	if(stats_file==NULL){
 	    mp_msg(MSGT_MENCODER,MSGL_ERR,"2pass failed: filename=%s\n", passtmpfile);
@@ -618,7 +587,7 @@ static int config(struct vf_instance *vf
 	    fclose(stats_file);
 	    /* fall through */
     case 1:
-	lavc_venc_context->flags|= CODEC_FLAG_PASS1;
+	lavc_venc_context->flags|= AV_CODEC_FLAG_PASS1;
 	stats_file= fopen(passtmpfile, "wb");
 	if(stats_file==NULL){
 	    mp_msg(MSGT_MENCODER,MSGL_ERR,"2pass failed: filename=%s\n", passtmpfile);
@@ -638,8 +607,8 @@ static int config(struct vf_instance *vf
 	  lavc_venc_context->noise_reduction = 0; // nr=0
 	  lavc_venc_context->mb_decision = 0; // mbd=0 ("realtime" encoding)
 
-	  lavc_venc_context->flags &= ~CODEC_FLAG_QPEL;
-	  lavc_venc_context->flags &= ~CODEC_FLAG_4MV;
+	  lavc_venc_context->flags &= ~AV_CODEC_FLAG_QPEL;
+	  lavc_venc_context->flags &= ~AV_CODEC_FLAG_4MV;
 	  lavc_venc_context->trellis = 0;
 	  av_dict_set(&opts, "mpv_flags", "-mv0", 0);
 	  av_dict_set(&opts, "mpv_flags", "-qp_rd-cbp_rd", 0);
@@ -648,13 +617,11 @@ static int config(struct vf_instance *vf
     }
     }
 
-    lavc_venc_context->me_method = ME_ZERO+lavc_param_vme;
-
     /* fixed qscale :p */
     if (lavc_param_vqscale >= 0.0)
     {
 	mp_msg(MSGT_MENCODER, MSGL_INFO, MSGTR_MPCODECS_UsingConstantQscale, lavc_param_vqscale);
-	lavc_venc_context->flags |= CODEC_FLAG_QSCALE;
+	lavc_venc_context->flags |= AV_CODEC_FLAG_QSCALE;
         lavc_venc_context->global_quality=
 	vf->priv->pic->quality = (int)(FF_QP2LAMBDA * lavc_param_vqscale + 0.5);
     }
@@ -693,7 +660,7 @@ static int control(struct vf_instance *v
 
     switch(request){
         case VFCTRL_FLUSH_FRAMES:
-            if(vf->priv->codec->capabilities & CODEC_CAP_DELAY)
+            if(vf->priv->codec->capabilities & AV_CODEC_CAP_DELAY)
                 while(encode_frame(vf, NULL, MP_NOPTS_VALUE) > 0);
             return CONTROL_TRUE;
         default:
--- a/libmpcodecs/vf_mcdeint.c
+++ b/libmpcodecs/vf_mcdeint.c
@@ -231,7 +231,7 @@ static int config(struct vf_instance *vf
             avctx_enc->gop_size = 300;
             avctx_enc->max_b_frames= 0;
             avctx_enc->pix_fmt = AV_PIX_FMT_YUV420P;
-            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
+            avctx_enc->flags = AV_CODEC_FLAG_QSCALE | AV_CODEC_FLAG_LOW_DELAY;
             avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
             avctx_enc->global_quality= 1;
             av_dict_set(&opts, "memc_only", "1", 0);
@@ -245,11 +245,11 @@ static int config(struct vf_instance *vf
             case 2:
                 avctx_enc->me_method= ME_ITER;
             case 1:
-                avctx_enc->flags |= CODEC_FLAG_4MV;
+                avctx_enc->flags |= AV_CODEC_FLAG_4MV;
                 avctx_enc->dia_size=2;
 //                avctx_enc->mb_decision = MB_DECISION_RD;
             case 0:
-                avctx_enc->flags |= CODEC_FLAG_QPEL;
+                avctx_enc->flags |= AV_CODEC_FLAG_QPEL;
             }
 
             avcodec_open2(avctx_enc, enc, &opts);
--- a/gui/util/bitmap.c
+++ b/gui/util/bitmap.c
@@ -95,7 +95,7 @@ static int pngRead(const char *fname, gu
         return 3;
     }
 
-    data = av_malloc(len + FF_INPUT_BUFFER_PADDING_SIZE);
+    data = av_malloc(len + AV_INPUT_BUFFER_PADDING_SIZE);
 
     if (!data) {
         fclose(file);
